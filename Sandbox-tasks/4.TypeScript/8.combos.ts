// Задание №8.
// Напишите функцию combos,
// которая принимает положительное целое число num и возвращает массив массивов положительных целых чисел,
// где сумма каждого массива равна num. Массивы не должны повторяться.
//
// Пример:
//
// combos(3);
// // Output:
// [
//     [ 3 ],
//     [ 1, 1, 1 ],
//     [ 1, 2 ]
// ]
//
// combos(10);
// // Output:
// [
//     [ 10 ],
//     [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
//     [ 1, 1, 1, 1, 1, 1, 1, 1, 2 ],
//     [ 1, 1, 1, 1, 1, 1, 1, 3 ],
//     ...
//     [ 4, 6 ],
//     [ 5, 5 ]
// ]
//________________________________________________________________________



// Данную задачу можно решить двумя способами: рекурсивно и итеративно
// Лучшим вариантом будет итеративное решение, так-как на больших объемах данных (если переданное число достаточно большое)
// Функция выполниться быстрее и потребует меньших затрат памяти и времени.


// Рекурсивный вариант решения задачи
// Созданная функция принимает один аргумент типа "число" и возвращает массив массивов,
// которые содержат результаты разложения числа на слагаемые
function combos(a: number): number[][] {
    // Создаю массив, который будет содержать результаты вычислений
    let result: number[][] = [];

    // Рекурсивная функция, которая будет отвечать за вычисления
    // Функция принимает как аргументы число и массив чисел
    function recursion(number: number, currentCombo: number[]) {
        // Проверяем на базовый случай, который приведет к завершению рекурсии
        // если текущее число это "0", значит мы собрали все слагаемые
        if (number === 0) {
            // Заносим текущий подмассив в массив результатов
            result.push([...currentCombo]);
            // Завершаем функцию с помощью оператора return
            return;
        }

        // В случае когда текущее число больше 0, значит мы не до конца разбили число на слагаемые.

        // Создаём переменную start, она будет отвечать за начало текущей итерации.
        // Переменная start нужна для того, чтобы избавиться от повторяющихся комбинаций чисел
        let start: number = currentCombo.length > 0 ? currentCombo[currentCombo.length - 1] : 1;

        // Перебор всех значений для текущего числа
        for (let i = start; i <= number; i++) {
            // Добавляем в текущую последовательность слагаемых i
            currentCombo.push(i);
            // После чего снова вызываем функцию recursion, и изменяем изначальные значения
            recursion(number - i, currentCombo);
            // Удаляем последний элемент текущего подмассива, чтобы продвинуться по итерации
            currentCombo.pop();
        }
    }

    // Вызываем рекурсивную функцию, начальные аргументы:
    // a - переданное в функцию combos число
    // [] - массив (подмассив), который будет хранить текущую комбинацию слагаемых
    recursion(a, []);
    // Возвращаем готовый массив результатов
    return result;
}

// Записываем результат выполнения функции combos в отдельную переменную для дальнейшего использования
const result: number[][] = combos(10);
console.log(result);

