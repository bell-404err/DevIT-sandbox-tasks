// Задание №7.
// Напишите функцию, которая берет объект любой вложенности и
// преобразует ее в единую плоскую карту с разными уровнями,
// разделенными косой чертой ( '/').
//
// Пример:
//
// const obj = {
//     a: {
//         b: {
//             c: 12,
//             d: 'Hello World'
//         },
//         e: [1,2,3]
//     }
// };
//
// mapObject(demoData);
// // Outputs: {
// 'a/b/c': 12,
//     'a/b/d': 'Hello World',
//     'a/e': [1,2,3]
// }
//________________________________________________________________________



// Тестовые данный для выполнения задания
const obj = {
    a: {
        b: {
            c: 12,
            d: 'Hello World'
        },
        e: [1, 2, 3]
    }
};

// Создаю ф-н которая будет преобразовывать объект в плоскую карту
// Функция принимает объект вида: ключ - строка, значение - любой тип,
// а возвращает объект
function mapObject(globalData: Record<string, any>): Record<string, any> {
    // Создаю объект, который будет содержать преобразованные данные
    let result: Record<string, any> = {};

    // Создаю функцию, которая будет совершать рекурсивные вызовы самой себя.
    // Функция будет принимать объект, а так же переменную для записи пути, тип которой - "строка"
    function recursion(localData: Record<string, any>, currentPath: string) {
        for (const key in localData) {
            // На каждой итерации цикла создаю переменную value, которая будет содержать значение текущего ключа
            // Тип переменной - "любой"
            const value: any = localData[key];
            // Создаю новый путь, тип переменной - "строка".
            // Тернарный оператор будет формировать текущий путь начиная от текущего ключа и до самого вложенного свойства
            const newPath: string = currentPath ? `${currentPath}/${key}` : key;
            // В случае когда значение текущего ключа это объект, исключая массивы: мы рекурсивно вызываем функцию
            if (typeof value === 'object' && !Array.isArray(value)) {
                // Как новые аргументы для функции recursion будут переданы:
                // value - значение текущего ключа
                // newPath - текущий путь сформированный из вложенных ключей и их свойств
                recursion(value, newPath);
            } else {
                // В случае если мы добрались до самого глубокого значения ключа и оно не является объектом,
                // мы просто присваиваем в результирующий объект (result) заполненный путь (newPath)
                // и значение текущего ключа по этому пути (value)
                result[newPath] = value;
            }
        }
    }

    // Запускаем рекурсивную функцию.
    // Начальными значениями будут переданный объект и пустая строка (будет записан путь к значению).
    recursion(globalData, '');
    // Возвращаем полученный объект с результатами выполнения функции
    return result;
}

// Записываем объект из функции mapObject для дальнейшего использования
const result: Record<string, any> = mapObject(obj);
console.log(result);


