// Задание №3.
// Напишите функцию обертку, которая на вход принимает массив функций и их параметров,
// а возвращает массив результатов их выполнения. Количество аргументов исполняемой функции не ограничено!
//
// Пример:
//
// const f1 = (cb) => {cb(1)}
// const f2 = (a, cb) => {cb(a)}
// const f3 = (a, b, cb) => {setTimeout(() => cb([a, b]), 1000)}
//
// bulkRun(
//     [
//         [f1, []],
//         [f2, [2]]
//         [f3, [3, 4]]
//     ]
// ).then(console.log)
// // Output: [1, 2, [3, 4]]

// Исходные данные (переписанные на TS)
const f1 = (cb: (result: number) => void) => { cb(1); };
const f2 = (a: number, cb: (result: number) => void) => { cb(a); };
const f3 = (a: number, b: number, cb: (result: number[]) => void) => {
    setTimeout(() => cb([a, b]), 1000);
};

// Создадим собственный тип, в котором укажем что будет принимать и возвращать каждая функция
// Используем "<T>" для указания на обобщенный тип
type FunctionWithArgs<T> = [(...args: any[]) => Promise<T>, any[]];

// Функция принимает созданный ранее тип, где каждая функция принимает обобщенный массив
// Функция будет возвращать массив Promis'ов с обобщенными типами
function bulkRun<T>(functionsWithArgs: FunctionWithArgs<T>[]): Promise<T[]> {

    // Создаю переменную массив, котора будет хранить массивы результатов выполнения
    const result: Promise<T>[] = [];

    // Перебираем массив.
    // Используем синтаксис деструктуризации для извлечения функций и их аргументов
    for (const [fn, args] of functionsWithArgs) {
        // На каждой итерации цикла будем создавать новый promise.
        // В промис передаем callback функцию resolve, для обработки результатов выполнения данного промиса.
        const promise = new Promise<T>((resolve) => {
            // С помощью метода length определяем количество аргументов для текущей функции
            const numberOfArguments: number = fn.length;
            // В случае если количество аргументов равно "0",
            // мы передаем управление в блок then с помощью callback функции resolve.
            if (numberOfArguments === 0) {
                resolve();
            } else {
                // В случае если в функцию были переданы аргументы, нам необходимо выполнить её.
                // result - это результат выполнения текущей функции, resolve передает result в блок кода then, а тот выводит его в консоль
                fn(...args, (...result) => resolve(result));
            }
        });
        // Добавляем результат выполнения каждого промиса в массив
        result.push(promise);
    }
    // Используем Promise.all, данный метод ожидает завершения выполнения всех переданных в него промисов.
    return Promise.all(result);
}

// Запуск функции
bulkRun([
    [f1, []],
    [f2, [2]],
    [f3, [3, 4]]
]).then(console.log);