// Задание №5.
// Написать обратный метод (см. задачу 4) objectToArray, который из объекта создаст массив.
// Пример:
//
// objectToArray({
//     name: 'developer',
//     age: 5,
//     skills: {
//         html: 4,
//         css: 5,
//         js: 5
//     }
// })
// Outputs: [['name', 'developer'], ['age', 5], ['skills', [['html', 4], ['css', 5], ['js', 5]]]
// _______________________________________________________________________________



// Исходный массив с данными
const obj = {
    name: 'developer',
    age: 5,
    skills: {
        html: 4,
        css: 5,
        js: 5
    }
}

// Создаю функцию, которая будет переводить данные из объекта в массив
// Функция принимает как аргумент объект, возвращает массив
function objectToArray(object: Record<string, any>): Array<[string, any]> {
    // Создаю массив, в который будут записаны все результаты
    // Массив будет содержать кортеж вида: "строка, значение любого типа"
    let resultArray: Array<[string, any]> = [];

    // Т.к при рекурсивном подходе ф-н будет вызывать сама себя, она будет создавать переменную resultArray каждый раз заново,
    // в результате таких действий могут возникнуть ошибки, поэтому внутри функции objectToArray я создаю новую ф-н recursive.
    // Ф-н recursive принимает как аргументы: объект и массив, а возвращает массив
    function recursive(object: Record<string, any>, resultArray: Array<[string, any]>): Array<[string, any]> {
        for (let key in object) {
            // Определяем базовый случай, который приведет к завершению рекурсии
            // В случае если текущий ключ объекта не содержит в качестве значения объект
            // Тогда записываем в результирующий массив пару "ключ: значение" в виде кортежа [ключ, значение]
            if (typeof object[key] !== 'object') {
                // При использовании "as" мы явно укажем TS что переменная должна быть строкой
                // Это может быть полезно, в ситуации когда ключи объекта - числа, а не строки.
                // Но в данном примере мы явно указали что ключи - строки.
                // const subArray = [key, object[key]] as [string, any];

                const subArray: [string, any] = [key, object[key]];
                resultArray.push(subArray);
            } else {
                // В случае если текущий ключ объекта содержит другой объект как значение,
                // записываем ключ в результирующий массив и делаем рекурсивный вызов функции
                // с передачей в нее этого объекта и пустого массива для записи результатов следующей итерации
                const subArray: [string, any] = [key, recursive(object[key], [])];
                resultArray.push(subArray);
            }
        }
        // Возвращаем массив с готовыми результатами
        return resultArray;
    }
    return recursive(object, resultArray);
}
// Помещаем результат вычисления в переменную для дальнейшего использования
// Явно укажем тип переменной result
const result: Array<[string, any]> = objectToArray(obj);
console.log(result);