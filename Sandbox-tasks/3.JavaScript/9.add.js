// Задание №9.
// Напишите функцию add,
// которая бы работала следующим образом add(1)(2)(7)...(n).
// Количество последовательных вызовов не ограничено.
//
// Пример:
//
// Number(add(1)(2)); // == 3
// Number(add(1)(2)(5)); // == 8
// Number(add(1)(2)(-3)(4)); //  == 4
// Number(add(1)(2)(3)(4)(-5)); // == 5

// Данная задача рассчитана на использование каррирования.
// Каррирование - это прием из функционального программирования, который позволяет выполнять функцию частично,
// по мере передачи ей аргументов. Суть в том, что запуск функции возвращает другую функцию.
// Вложенные функции могу иметь разный функционал. Один из примеров,
// в которых это может быть использование - подсчет скидки на товар (просто как пример)

// Создаем функцию
function add(firstNumber) {
    // Внутри функции add сразу создаем функцию sum, которая будет принимать второе слагаемое.
    const sum = (secondNumber) => {
        // В условии проверяем, передан ли аргумент для внутренней функции sum
        if (typeof secondNumber === 'undefined') {
            // В случае когда второго аргумента нет
            // (мы вызвали функцию только один раз "add(3)", или если вызов был в блоке else:
            // мы просто вернем переданное число (подразумевается, что когда второй аргумент не передан, он автоматически равен "0"
            // или если вызов функции add произошел в блоке else, функция примет сумму двух значений "firstNumber + secondNumber")
            // "3 + 0 = 3", поэтому вернем переданное число, или например "1 + 2 = 3" (если вызовы был вот таким: add(1)(2))
            return firstNumber;
        } else {
            // В случае если вторая функция так же получает аргумент (вторые и последующие скобки),
            // мы возвращаем add, и передаем ей сумму переданных чисел.
            return add(firstNumber + secondNumber);
        }
    };
    // Данный код работает из-за замыкания функций и их лексического окружения.
    // При первом вызове все просто: add - получает аргумент, а внутрення анонимная ф-н - не получает аргумент,
    // по условию просто возвращаем первый аргумент

    // При втором запуске (вторые скобочки "add(1)(2)")
    // для firstNumber определяется значение "1", а внутрення функция sum не найдя внутри себя переменной secondNumber
    // идет выше по уровню видимости, откуда получает второе значение "2".


    // Так-как из sum мы хотим вернуть число, нам нужно переопределить тип из объекта в примитив
    // Этот код работает так, что пока у нас приходят аргументы (add(1)(2)(3)(4)...) -
    // код постоянно будет попадать в блок else и суммировать 1 и 2 аргумент, затем суммировать (1+2 аргументы) и 3 аргумент,
    // затем ((1+2)+3 аргументы) и 4 аргумент. Только в случае если функция не получит последующего аргумента,
    // код пройдет проверку if () и вернет значение из sum в add. Код пойдет дальше и преобразует ответ sum в примитив
    sum.valueOf = () => firstNumber;
    return sum;
}

// Примеры использования
console.log(Number(add(1)(2))); // == 3
console.log(Number(add(1)(2)(5))); // == 8
console.log(Number(add(1)(2)(-3)(4))); // == 4
console.log(Number(add(1)(2)(3)(4)(-5))); // == 5